package webencodings

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

func GenerateDecodingTable() string {
	var result strings.Builder
	result.WriteString("// Code generated by mk_decoding_table.go; DO NOT EDIT.\n\n")
	result.WriteString("package webencodings\n\n")
	result.WriteString("// DecodingTable maps byte indices to their corresponding runes\n")
	result.WriteString("var DecodingTable = [256]rune{\n")

	for c := 0; c < 256; c++ {
		charValue := rune(c)
		if c >= 128 {
			charValue = rune(c + 0xF700)
		}

		// Generate proper Go rune literal
		var runeLiteral string
		switch {
		case charValue == '\t':
			runeLiteral = "'\\t'"
		case charValue == '\n':
			runeLiteral = "'\\n'"
		case charValue == '\r':
			runeLiteral = "'\\r'"
		case charValue == '\'':
			runeLiteral = "'\\''"
		case charValue == '\\':
			runeLiteral = "'\\\\'"
		case charValue >= 32 && charValue <= 126: // printable ASCII
			runeLiteral = fmt.Sprintf("'%c'", charValue)
		case charValue < 256:
			runeLiteral = fmt.Sprintf("'\\x%02x'", charValue)
		default:
			runeLiteral = fmt.Sprintf("'\\u%04x'", charValue)
		}

		result.WriteString(fmt.Sprintf("\t%s, // index %d\n", runeLiteral, c))
	}

	result.WriteString("}\n")

	// Write the generated code to decoding_table.go
	err := os.WriteFile("decoding_table.go", []byte(result.String()), 0644)
	if err != nil {
		panic(err)
	}

	// Format the generated file using gofmt
	cmd := exec.Command("gofmt", "-w", "decoding_table.go")
	if err := cmd.Run(); err != nil {
		fmt.Printf("Warning: Failed to format decoding_table.go: %v\n", err)
	}

	fmt.Println("Generated decoding_table.go successfully!")
	return result.String()
}

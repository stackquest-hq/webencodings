package webencodings

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"strings"
)

type Encoding struct {
	Labels []string `json:"labels"`
	Name   string   `json:"name"`
}

type EncodingGroup struct {
	Encodings []Encoding `json:"encodings"`
	Heading   string     `json:"heading"`
}

func GenerateLabels(url string) string {
	resp, err := http.Get(url)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	fmt.Println("Response status:", resp.Status)
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}

	var encodingGroups []EncodingGroup
	if err := json.Unmarshal(body, &encodingGroups); err != nil {
		panic(err)
	}

	var result strings.Builder
	result.WriteString("// Code generated by mk_labels.go; DO NOT EDIT.\n\n")
	result.WriteString("package webencodings\n\n")
	result.WriteString("import \"strings\"\n\n")
	result.WriteString("// Labels maps encoding labels to their canonical names\n")
	result.WriteString("var Labels = map[string]string{\n")

	for _, group := range encodingGroups {
		result.WriteString(fmt.Sprintf("\t// %s\n", group.Heading))
		for _, encoding := range group.Encodings {
			for _, label := range encoding.Labels {
				result.WriteString(fmt.Sprintf("\t%q: %q,\n", label, strings.ToLower(encoding.Name)))
			}
		}
		result.WriteString("\n")
	}

	result.WriteString("}\n\n")
	result.WriteString("// GetCanonicalName returns the canonical encoding name for a given label\n")
	result.WriteString("func GetCanonicalName(label string) (string, bool) {\n")
	result.WriteString("\tname, exists := Labels[strings.ToLower(label)]\n")
	result.WriteString("\treturn name, exists\n")
	result.WriteString("}\n")

	// Write the generated code to labels.go
	err = os.WriteFile("labels.go", []byte(result.String()), 0644)
	if err != nil {
		panic(err)
	}

	// Format the generated file using gofmt
	cmd := exec.Command("gofmt", "-w", "labels.go")
	if err := cmd.Run(); err != nil {
		fmt.Printf("Warning: Failed to format labels.go: %v\n", err)
	}

	fmt.Println("Generated labels.go successfully!")
	return result.String()
}
